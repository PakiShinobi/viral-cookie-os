# Database Schema

## Overview

PostgreSQL hosted on Supabase. Migrations managed via the Supabase CLI. Row Level Security (RLS) enabled on all tables. UUIDs for all primary keys (generated by `gen_random_uuid()`).

The schema covers four concerns: content lifecycle, transcripts, publishing records, and AI generation logs.

## Tables

### content

The central table. Every piece of content in the system -- video, podcast, blog post, short-form clip -- is a row here.

```sql
create table content (
    id          uuid primary key default gen_random_uuid(),
    user_id     uuid not null references auth.users(id) on delete cascade,
    title       text not null,
    content_type text not null default 'video'
                check (content_type in ('video', 'podcast', 'blog_post', 'short_form', 'newsletter')),
    stage       text not null default 'idea'
                check (stage in ('idea', 'brief', 'script', 'record', 'edit', 'review', 'publish', 'distribute', 'archived')),
    brief       text,
    script      text,
    blog_body   text,
    seo_title   text,
    seo_description text,
    target_keywords text[],
    tags        text[] default '{}',
    due_date    date,
    created_at  timestamptz not null default now(),
    updated_at  timestamptz not null default now()
);

create index idx_content_user on content (user_id);
create index idx_content_stage on content (user_id, stage);
```

**Notes:**

- `user_id` references Supabase Auth's built-in `auth.users` table. In the MVP, content is scoped to individual users (no multi-user workspaces yet).
- `brief`, `script`, and `blog_body` are nullable text fields populated as the content moves through pipeline stages.
- `seo_title`, `seo_description`, and `target_keywords` are populated during blog generation.
- `stage` is the current pipeline position. Transitions are enforced in application code, not database constraints, to keep flexibility during the MVP.

### media

Files attached to content objects. Metadata only -- actual files live in Supabase Storage.

```sql
create table media (
    id          uuid primary key default gen_random_uuid(),
    content_id  uuid not null references content(id) on delete cascade,
    user_id     uuid not null references auth.users(id) on delete cascade,
    file_name   text not null,
    storage_path text not null,
    mime_type   text not null,
    file_size   bigint not null,
    duration_ms integer,
    media_type  text not null
                check (media_type in ('video', 'audio', 'image')),
    created_at  timestamptz not null default now()
);

create index idx_media_content on media (content_id);
```

**Notes:**

- `storage_path` is the key within the Supabase Storage `media` bucket (e.g., `user-uuid/content-uuid/recording.mp4`).
- `duration_ms` is extracted client-side for audio/video and stored on upload.
- One content object can have multiple media files (e.g., a video file and a thumbnail image).

### transcripts

Structured transcription output linked to a media file.

```sql
create table transcripts (
    id          uuid primary key default gen_random_uuid(),
    content_id  uuid not null references content(id) on delete cascade,
    media_id    uuid not null references media(id) on delete cascade,
    full_text   text not null,
    segments    jsonb not null default '[]',
    language    text not null default 'en',
    created_at  timestamptz not null default now(),
    updated_at  timestamptz not null default now()
);

create index idx_transcripts_content on transcripts (content_id);
create index idx_transcripts_search on transcripts using gin (to_tsvector('english', full_text));
```

`segments` JSONB structure:

```json
[
    {
        "start_ms": 0,
        "end_ms": 4500,
        "text": "Welcome to the show.",
        "speaker": "Speaker 1"
    }
]
```

**Notes:**

- `full_text` is the concatenated plain-text transcript for full-text search.
- `segments` stores timestamped chunks for playback sync in the UI.
- One media file has one transcript. Re-transcribing replaces the existing row.

### publishing_records

Tracks every publish action to an external platform.

```sql
create table publishing_records (
    id          uuid primary key default gen_random_uuid(),
    content_id  uuid not null references content(id) on delete cascade,
    platform    text not null
                check (platform in ('youtube', 'shopify')),
    status      text not null default 'pending'
                check (status in ('pending', 'in_progress', 'success', 'failed')),
    remote_id   text,
    remote_url  text,
    error       text,
    payload     jsonb,
    published_at timestamptz,
    created_at  timestamptz not null default now(),
    updated_at  timestamptz not null default now()
);

create index idx_publishing_content on publishing_records (content_id);
create index idx_publishing_status on publishing_records (status) where status in ('pending', 'failed');
```

**Notes:**

- `remote_id` is the platform's identifier (YouTube video ID, Shopify article ID).
- `remote_url` is the public URL of the published asset.
- `payload` stores the full request sent to the platform API for debugging.
- `error` stores the error message on failure.
- A content object can have multiple publishing records (one per platform, and historical records from re-publishes).

### ai_generation_logs

Audit trail of every AI generation call for usage tracking and debugging.

```sql
create table ai_generation_logs (
    id          uuid primary key default gen_random_uuid(),
    content_id  uuid references content(id) on delete set null,
    user_id     uuid not null references auth.users(id),
    operation   text not null
                check (operation in ('expand_idea', 'generate_script', 'generate_blog', 'refine')),
    model       text not null,
    input_tokens integer not null,
    output_tokens integer not null,
    accepted    boolean,
    created_at  timestamptz not null default now()
);

create index idx_ai_logs_user on ai_generation_logs (user_id, created_at);
```

**Notes:**

- `content_id` is nullable because some generations (e.g., exploratory idea expansion) may not be linked to a specific content object yet.
- `accepted` tracks whether the user accepted the generation into their content. Null means the user hasn't acted on it yet.
- Token counts are used for usage tracking and billing enforcement.

### user_integrations

Stores OAuth tokens for connected platforms (YouTube, Shopify).

```sql
create table user_integrations (
    id          uuid primary key default gen_random_uuid(),
    user_id     uuid not null references auth.users(id) on delete cascade,
    platform    text not null
                check (platform in ('youtube', 'shopify')),
    access_token text not null,
    refresh_token text,
    token_expires_at timestamptz,
    platform_account_id text,
    platform_account_name text,
    config      jsonb not null default '{}',
    created_at  timestamptz not null default now(),
    updated_at  timestamptz not null default now(),

    unique (user_id, platform)
);

create index idx_integrations_user on user_integrations (user_id);
```

**Notes:**

- One row per user per platform. Reconnecting replaces the existing tokens.
- `access_token` and `refresh_token` are encrypted at the application layer before storage.
- `config` stores platform-specific defaults: default YouTube playlist, default Shopify blog handle, etc.
- `platform_account_id` / `platform_account_name` store the connected channel or store name for display in the UI.

## Row Level Security

Every table has RLS enabled. Policies follow the same pattern:

```sql
-- Users can only access their own data
alter table content enable row level security;

create policy "Users can view own content"
    on content for select
    using (auth.uid() = user_id);

create policy "Users can insert own content"
    on content for insert
    with check (auth.uid() = user_id);

create policy "Users can update own content"
    on content for update
    using (auth.uid() = user_id);

create policy "Users can delete own content"
    on content for delete
    using (auth.uid() = user_id);
```

The same four-policy pattern (select, insert, update, delete) is applied to `media`, `transcripts`, `publishing_records`, `ai_generation_logs`, and `user_integrations`.

For tables where `user_id` is not directly on the row (like `transcripts`), policies join through the parent table:

```sql
create policy "Users can view own transcripts"
    on transcripts for select
    using (
        exists (
            select 1 from content
            where content.id = transcripts.content_id
            and content.user_id = auth.uid()
        )
    );
```

## Updated At Trigger

A reusable trigger keeps `updated_at` current on every update:

```sql
create or replace function update_updated_at()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql;

create trigger set_updated_at before update on content
    for each row execute function update_updated_at();

create trigger set_updated_at before update on transcripts
    for each row execute function update_updated_at();

create trigger set_updated_at before update on publishing_records
    for each row execute function update_updated_at();

create trigger set_updated_at before update on user_integrations
    for each row execute function update_updated_at();
```

## Entity Relationships

```
auth.users (Supabase managed)
    │
    ├──< content
    │       ├──< media
    │       │       └──< transcripts
    │       ├──< publishing_records
    │       └──< ai_generation_logs
    │
    └──< user_integrations
```

Six application tables. One Supabase-managed auth table. No junction tables, no workspace layer, no role management. Flat and simple for the MVP.
